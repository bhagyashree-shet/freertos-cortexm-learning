Environment
Architecture: ARM Cortex-M3
RTOS: FreeRTOS Kernel (official GitHub)
Toolchain: arm-none-eabi-gcc
Emulator: QEMU (mps2-an385)
Debugger: gdb-multiarch

Program 1 — Minimal FreeRTOS Bring-Up (Single Task, No Delay)
Objective

Verify that:

FreeRTOS scheduler starts correctly

A task executes under RTOS control

Task context (stack, registers) is correctly set up

What Was Observed in GDB

main() runs in bare-metal context (before scheduler start)

After vTaskStartScheduler():

Task runs using PSP, not MSP

CPU remains in privileged mode

xPSR indicates Thumb state

pxCurrentTCB confirms:

Task name

Task priority

Task stack range

Task is in the Ready list

Key Takeaways

main() is not a task

Each task has its own stack and TCB

A running task is still in the Ready list

RTOS control begins at vTaskStartScheduler()
###############################################################################################################################################
Program 2 — Task Blocking with vTaskDelay() (Single Task + Idle Task)
Objective

Understand how time-based blocking works in FreeRTOS.

What Was Observed in GDB

When a task calls vTaskDelay():

Task is moved from the Ready list to the Delayed list

An absolute wake-up tick (xItemValue) is assigned

Blocking happens before the context switch

CPU switches to the Idle task when no application task is READY

After the delay expires:

SysTick moves the task back to the Ready list

Task resumes execution (does not restart)

Key Takeaways

vTaskDelay() does not busy-wait

Blocking is implemented via kernel lists

Idle task runs only when no other task is READY

Tasks resume, they do not restart
###############################################################################################################################
Program 3 — Priority Scheduling without Blocking (Two Tasks)
Objective

Observe priority-based scheduling without time delays.

Setup

Two tasks

Different priorities

No blocking or yielding

What Was Observed

The higher-priority task runs forever

Lower-priority task never executes

Time slicing does not occur across priorities

Key Takeaways

FreeRTOS is priority-driven

A READY high-priority task can starve lower-priority tasks

Blocking or yielding is required for fairness
############################################################################################################################################################
Program 4 — Priority + Blocking + Preemption (Core RTOS Behavior)
Objective

Understand true preemption using:

vTaskDelay()

SysTick

PendSV

What Was Proven Step-by-Step
1. Blocking switch

High-priority task calls vTaskDelay()

Task becomes BLOCKED

Scheduler switches to lower-priority task

Context switch happens via PendSV

2. Preemption switch

SysTick interrupt increments tick count

When delay expires:

High-priority task becomes READY

Scheduler detects higher priority

PendSV performs context switch

High-priority task preempts immediately

Critical Insight

SysTick decides when a switch is needed

PendSV performs the actual context switch

Preemption does not occur in task code

Multiple PendSV invocations may occur:

Blocking switch

Preemption switch
